package name.huguogang.Algorithms.LeetCode;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.Stack;

import sun.reflect.generics.reflectiveObjects.NotImplementedException;

/**
 * TODO: tree in/post/pre order using stack
 * TODO: tree in/post/pre order using morris
 * TODO: (strStr) Rabin-Karp algorithm, KMP algorithm, and the Boyer- Moore algorithm
 * 
 * @author ghu
 *
 */
@SuppressWarnings("unused")
public class Solution {

    /**
     * Find the contiguous subarray within an array (containing at least one number) which has the largest product.
     * 
     * For example, given the array [2,3,-2,4],
     * the contiguous subarray [2,3] has the largest product = 6.
     * 
     * @param A
     * @return
     */
    public int maxProduct(int[] A) {
        // analysis:
        // * 0 is a breaker, no max can cross it? except when 0 itself is the max
        // * even number of negative numbers will product positive product
        throw new NotImplementedException();
    }

    /**
     * Binary Tree Inorder Traversal
     * 
     * Iterative version, using stack
     * 
     * @param root
     * @return
     */
    public List<Integer> inorderTraversal(TreeNode root) {
        throw new NotImplementedException();
    }

    /**
     * Sort Colors
     * 
     * Given an array with n objects colored red, white or blue, sort them so that objects of the same color are
     * adjacent, with the colors in the order red, white and blue.
     * 
     * Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
     * 
     * @param A
     */
    public void sortColors(int[] A) {

    }

    
}